## Preprocesamiento de Datos

El análisis de vegetación dunar requirió un proceso de preprocesamiento para transformar los datos originales en un formato adecuado para el análisis estadístico. Los datos provienen de un libro de Excel (`db_species_20250214.xlsx`) que contiene información sobre presencia y abundancia de especies vegetales en diferentes parcelas de muestreo, así como datos de cobertura del suelo y prácticas de gestión para las provincias de Girona, Barcelona y Tarragona.

### Estructura de los Datos Originales

El conjunto de datos principal incluye 278 observaciones de parcelas distribuidas en diferentes playas y transectos, con registros de abundancia para 147 especies vegetales usando una escala ordinal de 0 a 5. Adicionalmente, se dispone de información sobre porcentajes de cobertura del suelo en radios de 50m y 100m desde los puntos de muestreo, y datos sobre prácticas de gestión y grados de protección para cada área.

### Limpieza y Transformación

El proceso de preprocesamiento se implementó en R utilizando el ecosistema tidyverse. Las principales transformaciones aplicadas fueron:

```{r}
#| label: load-packages
#| echo: false
#| eval: true
#| output: false
## Cargar paquetes requeridos
library(tidyverse)
library(readxl)
library(conflicted)
library(ggplot2)
library(janitor)
library(dplyr)
```

**Carga y limpieza inicial**: Se eliminaron columnas completamente vacías y se estandarizaron los nombres de columnas usando el paquete `janitor` para asegurar consistencia en la nomenclatura.

```{r}
#| label: load-data
#| echo: false
#| eval: true
#| output: false
## Cargar el conjunto de datos principal
main_data <- read_excel("../data/db_species_20250214.xlsx", sheet = "original_data")
main_data <- main_data %>% select(where(~ !all(is.na(.))))

## Limpiar nombres de columnas
main_data <- main_data %>% janitor::clean_names()
```

**Conversión de tipos de datos**: Los valores de abundancia de especies se transformaron a formato numérico, implementando verificaciones para detectar valores problemáticos durante la conversión.

```{r}
#| label: numeric-conversion
#| echo: false
#| eval: true
#| output: false
## Encontrar el índice de la columna EUNIS
eunis_col_index <- which(grepl("eunis", names(main_data), ignore.case = TRUE))
if(length(eunis_col_index) == 0) {
  eunis_col_index <- ncol(main_data) + 1
} else {
  eunis_col_index <- min(eunis_col_index)
}

## Convertir columnas de abundancia a numéricas
for(i in 2:min(ncol(main_data), eunis_col_index - 1)) {
  main_data[[i]] <- as.numeric(as.character(main_data[[i]]))
}
```

```{r}
#| label: column-reorder
#| echo: false
#| eval: true
#| output: false
## Organizar columnas en orden lógico
species_cols <- setdiff(names(main_data),
                      c("plot", "id_beach", "beach", "id_transect", "id_plot", "transect", "eunis"))

ordered_cols <- c("plot", "id_beach", "beach", "id_transect", "id_plot", "transect", "eunis", species_cols)
main_data <- main_data %>% select(all_of(ordered_cols), everything())

## Guardar los datos principales procesados
save(main_data, file = "../data/processed_data_clean.RData")
```

**Procesamiento de datos auxiliares**: Los datos de cobertura del suelo y gestión se procesaron por separado para cada provincia, estandarizando la estructura y convirtiendo variables categóricas a factores cuando fue apropiado.

```{r}
#| label: land-cover-processing
#| echo: false
#| eval: true
#| output: false
## Función para procesar datos de cobertura del suelo
process_land_cover <- function(sheet_name) {
  land_cover_data <- read_excel("../data/db_species_20250214.xlsx", sheet = sheet_name)
  land_cover_data <- land_cover_data %>% janitor::clean_names()
  
  ## Identificar columnas relevantes
  id_col <- grep("^id_beach$|^id_plot$", names(land_cover_data), value = TRUE)[1]
  cols_50m <- grep("50m", names(land_cover_data), value = TRUE)
  cols_100m <- grep("100m", names(land_cover_data), value = TRUE)
  
  distance_cols <- c(cols_50m, cols_100m)
  selected_cols <- c(id_col, distance_cols)
  
  ## Filtrar y convertir tipos de datos
  filtered_data <- land_cover_data %>% 
    select(all_of(selected_cols)) %>% 
    distinct()
  
  for(col in distance_cols) {
    filtered_data[[col]] <- as.numeric(filtered_data[[col]])
  }
  
  filtered_data[[id_col]] <- as.integer(filtered_data[[id_col]])
  
  return(filtered_data)
}

## Procesar datos por provincia
girona_land_cover <- process_land_cover("girona_land cover")
barcelona_land_cover <- process_land_cover("barcelona_land cover")
tarragona_land_cover <- process_land_cover("tarragona_land cover")

land_cover_data <- list(
  "Girona" = girona_land_cover,
  "Barcelona" = barcelona_land_cover,
  "Tarragona" = tarragona_land_cover
)

save(land_cover_data, file = "../data/all_land_cover_data.RData")
```

```{r}
#| label: management-data-processing
#| echo: false
#| eval: true
#| output: false
## Función para procesar datos de gestión
process_management <- function(sheet_name) {
  management_data <- read_excel("../data/db_species_20250214.xlsx", sheet = sheet_name)
  management_data <- management_data %>% janitor::clean_names()
  
  ## Identificar columnas esperadas
  expected_cols <- c(
    "id_plot", "id_beach", "beach",
    "managed_paths", "rope_fences", "mechanical_cleaning",
    "surface_area_occupied_by_seasonal_services_and_amenities_on_or_less_than_5_m_from_the_dunes",
    "surface_area_of_parking_or_other_fixed_services_on_or_less_than_5_m_from_the_dunes",
    "protection_of_the_system_and_the_immediate_environment",
    "degree_of_protection_according_to_the_iucn_classification"
  )
  
  ## Buscar columnas coincidentes
  actual_cols <- vector("character", length(expected_cols))
  for (i in seq_along(expected_cols)) {
    pattern <- expected_cols[i]
    simple_pattern <- gsub("_", ".*", pattern)
    matches <- grep(simple_pattern, names(management_data), ignore.case = TRUE, value = TRUE)
    
    if (length(matches) > 0) {
      actual_cols[i] <- matches[1]
    } else {
      actual_cols[i] <- NA
    }
  }
  
  actual_cols <- actual_cols[!is.na(actual_cols)]
  
  if (length(actual_cols) > 0) {
    filtered_data <- management_data %>% select(all_of(actual_cols))
    
    ## Convertir tipos de datos apropiados
    id_plot_col <- grep("id.*plot", names(filtered_data), ignore.case = TRUE, value = TRUE)[1]
    id_beach_col <- grep("id.*beach", names(filtered_data), ignore.case = TRUE, value = TRUE)[1]
    
    if (!is.na(id_plot_col)) {
      filtered_data[[id_plot_col]] <- as.integer(filtered_data[[id_plot_col]])
    }
    
    if (!is.na(id_beach_col)) {
      filtered_data[[id_beach_col]] <- as.integer(filtered_data[[id_beach_col]])
    }
    
    ## Convertir variables categóricas a factores
    for (col in names(filtered_data)) {
      if (is.character(filtered_data[[col]]) &&
          !grepl("^id|^beach$", col, ignore.case = TRUE)) {
        unique_vals <- unique(na.omit(filtered_data[[col]]))
        if (length(unique_vals) < 10) {
          filtered_data[[col]] <- factor(filtered_data[[col]])
        }
      }
    }
    
    return(filtered_data)
  } else {
    return(NULL)
  }
}

## Procesar datos de gestión por provincia
girona_management <- process_management("girona_management")
barcelona_management <- process_management("barcelona_management")
tarragona_management <- process_management("tarragona_management")

management_data <- list(
  "Girona" = girona_management,
  "Barcelona" = barcelona_management,
  "Tarragona" = tarragona_management
)

save(management_data, file = "../data/all_management_data.RData")
```

### Validación de Datos

Se implementó un sistema de validación para verificar la integridad y calidad de los datos procesados. Este proceso incluyó verificaciones de formato, rangos de valores válidos y consistencia entre variables relacionadas. Para los datos principales, se confirmó que los valores de abundancia de especies estuvieran en el rango esperado (0-5) y que los identificadores de parcelas mantuvieran la estructura correcta. Los datos de cobertura del suelo se validaron verificando que los porcentajes sumaran aproximadamente 100% para cada distancia de medición.

```{r}
#| label: validation-execution
#| echo: false
#| eval: true
#| output: false
## Cargar y validar datos principales
if (file.exists("../data/processed_data_clean.RData")) {
  load("../data/processed_data_clean.RData")
  
  ## Validaciones básicas
  cat("Validación de datos principales:\n")
  cat("- Dimensiones:", nrow(main_data), "filas x", ncol(main_data), "columnas\n")
  cat("- Valores de abundancia válidos (0-5):", 
      all(sapply(main_data[,8:ncol(main_data)], function(x) all(x >= 0 & x <= 5, na.rm = TRUE))), "\n")
}

## Cargar y validar datos de cobertura del suelo
if (file.exists("../data/all_land_cover_data.RData")) {
  load("../data/all_land_cover_data.RData")
  
  cat("\nValidación de datos de cobertura del suelo:\n")
  for(region in names(land_cover_data)) {
    cat("-", region, ":", nrow(land_cover_data[[region]]), "observaciones\n")
  }
}

## Cargar y validar datos de gestión
if (file.exists("../data/all_management_data.RData")) {
  load("../data/all_management_data.RData")
  
  cat("\nValidación de datos de gestión:\n")
  for(region in names(management_data)) {
    if(!is.null(management_data[[region]])) {
      cat("-", region, ":", nrow(management_data[[region]]), "observaciones\n")
    }
  }
}
```

Como resultado del preprocesamiento, se generaron tres archivos de datos limpios y estructurados: `processed_data_clean.RData` para las observaciones de especies, `all_land_cover_data.RData` para los datos de cobertura del suelo, y `all_management_data.RData` para las prácticas de gestión. Estos archivos constituyen la base para los análisis estadísticos posteriores del proyecto.
