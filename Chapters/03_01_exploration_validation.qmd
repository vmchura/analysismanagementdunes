## Preprocesamiento de Datos

Transformación de datos originales de vegetación dunar para análisis estadístico a partir del archivo de datos con 278 observaciones de 147 especies en escala ordinal 0-5.

```{r}
#| label: load-packages
#| echo: false
#| eval: true
#| output: false
## Cargar paquetes requeridos
library(tidyverse)
library(readxl)
library(conflicted)
library(ggplot2)
library(janitor)
library(dplyr)
library(here)
```

```{r}
#| label: load-data
#| echo: false
#| eval: true
#| output: false
## Cargar el conjunto de datos principal
main_data <- read_excel(here("data","db_species_20250214.xlsx"), sheet = "original_data")
main_data <- main_data %>% select(where(~ !all(is.na(.))))

## Limpiar nombres de columnas
main_data <- main_data %>% janitor::clean_names()
```

```{r}
#| label: numeric-conversion
#| echo: false
#| eval: true
#| output: false
## Encontrar el índice de la columna EUNIS
eunis_col_index <- which(grepl("eunis", names(main_data), ignore.case = TRUE))
if(length(eunis_col_index) == 0) {
  eunis_col_index <- ncol(main_data) + 1
} else {
  eunis_col_index <- min(eunis_col_index)
}

## Convertir columnas de abundancia a numéricas
for(i in 2:min(ncol(main_data), eunis_col_index - 1)) {
  main_data[[i]] <- as.numeric(as.character(main_data[[i]]))
}
```

```{r}
#| label: column-reorder
#| echo: false
#| eval: true
#| output: false
## Organizar columnas en orden lógico
species_cols <- setdiff(names(main_data),
                      c("plot", "id_beach", "beach", "id_transect", "id_plot", "transect", "eunis"))

ordered_cols <- c("plot", "id_beach", "beach", "id_transect", "id_plot", "transect", "eunis", species_cols)
main_data <- main_data %>% select(all_of(ordered_cols), everything())

## Guardar los datos principales procesados
save(main_data, file = here("data","processed_data_clean.RData"))
```

```{r}
#| label: land-cover-processing
#| echo: false
#| eval: true
#| output: false
## Función para procesar datos de cobertura del suelo
process_land_cover <- function(sheet_name) {
  land_cover_data <- read_excel(here("data","db_species_20250214.xlsx"), sheet = sheet_name)
  land_cover_data <- land_cover_data %>% janitor::clean_names()
  
  ## Identificar columnas relevantes
  id_col <- grep("^id_beach$|^id_plot$", names(land_cover_data), value = TRUE)[1]
  cols_50m <- grep("50m", names(land_cover_data), value = TRUE)
  cols_100m <- grep("100m", names(land_cover_data), value = TRUE)
  
  distance_cols <- c(cols_50m, cols_100m)
  selected_cols <- c(id_col, distance_cols)
  
  ## Filtrar y convertir tipos de datos
  filtered_data <- land_cover_data %>% 
    select(all_of(selected_cols)) %>% 
    distinct()
  
  for(col in distance_cols) {
    filtered_data[[col]] <- as.numeric(filtered_data[[col]])
  }
  
  filtered_data[[id_col]] <- as.integer(filtered_data[[id_col]])
  
  return(filtered_data)
}

## Procesar datos por provincia
girona_land_cover <- process_land_cover("girona_land cover")
barcelona_land_cover <- process_land_cover("barcelona_land cover")
tarragona_land_cover <- process_land_cover("tarragona_land cover")

land_cover_data <- list(
  "Girona" = girona_land_cover,
  "Barcelona" = barcelona_land_cover,
  "Tarragona" = tarragona_land_cover
)

save(land_cover_data, file = here("data","all_land_cover_data.RData"))
```

```{r}
#| label: management-data-processing
#| echo: false
#| eval: true
#| output: false
## Función para procesar datos de gestión
process_management <- function(sheet_name) {
  management_data <- read_excel(here("data","db_species_20250214.xlsx"), sheet = sheet_name)
  management_data <- management_data %>% janitor::clean_names()
  
  ## Identificar columnas esperadas
  expected_cols <- c(
    "id_plot", "id_beach", "beach",
    "managed_paths", "rope_fences", "mechanical_cleaning",
    "surface_area_occupied_by_seasonal_services_and_amenities_on_or_less_than_5_m_from_the_dunes",
    "surface_area_of_parking_or_other_fixed_services_on_or_less_than_5_m_from_the_dunes",
    "protection_of_the_system_and_the_immediate_environment",
    "degree_of_protection_according_to_the_iucn_classification"
  )
  
  ## Buscar columnas coincidentes
  actual_cols <- vector("character", length(expected_cols))
  for (i in seq_along(expected_cols)) {
    pattern <- expected_cols[i]
    simple_pattern <- gsub("_", ".*", pattern)
    matches <- grep(simple_pattern, names(management_data), ignore.case = TRUE, value = TRUE)
    
    if (length(matches) > 0) {
      actual_cols[i] <- matches[1]
    } else {
      actual_cols[i] <- NA
    }
  }
  
  actual_cols <- actual_cols[!is.na(actual_cols)]
  
  if (length(actual_cols) > 0) {
    filtered_data <- management_data %>% select(all_of(actual_cols))
    
    ## Convertir tipos de datos apropiados
    id_plot_col <- grep("id.*plot", names(filtered_data), ignore.case = TRUE, value = TRUE)[1]
    id_beach_col <- grep("id.*beach", names(filtered_data), ignore.case = TRUE, value = TRUE)[1]
    
    if (!is.na(id_plot_col)) {
      filtered_data[[id_plot_col]] <- as.integer(filtered_data[[id_plot_col]])
    }
    
    if (!is.na(id_beach_col)) {
      filtered_data[[id_beach_col]] <- as.integer(filtered_data[[id_beach_col]])
    }
    
    ## Convertir variables categóricas a factores
    for (col in names(filtered_data)) {
      if (is.character(filtered_data[[col]]) &&
          !grepl("^id|^beach$", col, ignore.case = TRUE)) {
        unique_vals <- unique(na.omit(filtered_data[[col]]))
        if (length(unique_vals) < 10) {
          filtered_data[[col]] <- factor(filtered_data[[col]])
        }
      }
    }
    
    return(filtered_data)
  } else {
    return(NULL)
  }
}

## Procesar datos de gestión por provincia
girona_management <- process_management("girona_management")
barcelona_management <- process_management("barcelona_management")
tarragona_management <- process_management("tarragona_management")

management_data <- list(
  "Girona" = girona_management,
  "Barcelona" = barcelona_management,
  "Tarragona" = tarragona_management
)

save(management_data, file = here("data","all_management_data.RData"))
```

### Validación de Datos

```{r}
#| label: validation-execution
#| echo: false
#| eval: true
#| output: false
## Cargar y validar datos principales
if (file.exists(here("data","processed_data_clean.RData"))) {
  load(here("data","processed_data_clean.RData"))
  
  ## Validaciones básicas
  cat("Validación de datos principales:\n")
  cat("- Dimensiones:", nrow(main_data), "filas x", ncol(main_data), "columnas\n")
  cat("- Valores de abundancia válidos (0-5):", 
      all(sapply(main_data[,8:ncol(main_data)], function(x) all(x >= 0 & x <= 5, na.rm = TRUE))), "\n")
}

## Cargar y validar datos de cobertura del suelo
if (file.exists(here("data","all_land_cover_data.RData"))) {
  load(here("data","all_land_cover_data.RData"))
  
  cat("\nValidación de datos de cobertura del suelo:\n")
  for(region in names(land_cover_data)) {
    cat("-", region, ":", nrow(land_cover_data[[region]]), "observaciones\n")
  }
}

## Cargar y validar datos de gestión
if (file.exists(here("data","all_management_data.RData"))) {
  load(here("data","all_management_data.RData"))
  
  cat("\nValidación de datos de gestión:\n")
  for(region in names(management_data)) {
    if(!is.null(management_data[[region]])) {
      cat("-", region, ":", nrow(management_data[[region]]), "observaciones\n")
    }
  }
}
```

El preprocesamiento genera tres archivos de datos limpios: observaciones de especies, cobertura del suelo y prácticas de gestión por provincia.
